\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{float}
\usepackage{caption}
\usepackage{setspace}
\usepackage{enumitem}
\geometry{margin=2.5cm}
\onehalfspacing


\title{
\textbf{Raport z realizacji projektu programistycznego} \\[0.5cm]
\large System biblioteczny
}

\author{
Autorzy (grupa C): \\[0.2cm]
Dawid Błaszczyk - 280518 \\
Błazej Kowal - 280655 \\
Alina Lenart - 280588 \\
Bartosz Wacławiak - 280462 \\[0.4cm]
Prowadzący laboratorium: \\
dr inż. Krzysztof Chudzik
}

\date{
Data ukończenia pracy: \\ 
25.01.2025
}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

% Spis treści
\tableofcontents
\newpage

\section{Wymagania projektowe}

\subsection{Wymagania funkcjonalne}

System biblioteczny IoT musi spełniać następujące wymagania funkcjonalne:

\subsubsection{Obsługa kart RFID}
\begin{enumerate}[label=\textbf{W1.1.1.\arabic*}]
    \item System musi umożliwiać odczyt kart RFID za pomocą czytnika MFRC522.
    \item System musi automatycznie wykrywać przyłożenie i zabranie karty RFID.
    \item Odczytany identyfikator karty (UID) musi być konwertowany do formatu szesnastkowego i przesyłany do serwera centralnego.
    \item System musi rozróżniać między kartami klientów biblioteki i kartami przypisanymi do książek.
\end{enumerate}

\subsubsection{Zarządzanie bazą danych}
\begin{enumerate}[label=\textbf{W1.1.2.\arabic*}]
    \item System musi przechowywać informacje o klientach (imię, nazwisko, powiązana karta RFID).
    \item System musi przechowywać informacje o książkach (tytuł, autor, powiązana karta RFID).
    \item System musi rejestrować wypożyczenia i zwroty książek z datami operacji.
    \item System musi umożliwiać automatyczne tworzenie nowych rekordów kart przy pierwszym skanowaniu nieznanego UID.
\end{enumerate}

\subsubsection{Proces wypożyczania i zwracania}
\begin{enumerate}[label=\textbf{W1.1.3.\arabic*}]
    \item System musi umożliwiać wypożyczenie książki poprzez zeskanowanie karty klienta, a następnie karty książki.
    \item System musi umożliwiać zwrot książki przy pomocy zeskanowania karty klienta.
    \item System musi wyświetlać informacje o aktywnych wypożyczeniach klienta po zeskanowaniu jego karty.
    \item System musi weryfikować poprawność operacji (np. czy książka jest dostępna, czy klient już ją wypożyczył).
\end{enumerate}

\subsubsection{Interfejs użytkownika}
\begin{enumerate}[label=\textbf{W1.1.4.\arabic*}]
    \item System musi posiadać webowy interfejs graficzny dostępny przez przeglądarkę.
    \item Interfejs musi umożliwiać przeglądanie listy wszystkich klientów, książek i wypożyczeń.
    \item Interfejs musi umożliwiać ręczne dodawanie, edycję i usuwanie klientów oraz książek.
    \item Interfejs musi wyświetlać informacje o zeskanowanej karcie w czasie rzeczywistym.
    \item Interfejs musi umożliwiać przeprowadzenie pełnego procesu wypożyczania/zwrotu z graficznym przewodnikiem.
\end{enumerate}

\subsubsection{Komunikacja MQTT}
\begin{enumerate}[label=\textbf{W1.1.5.\arabic*}]
    \item Terminale RFID (Raspberry Pi) muszą komunikować się z serwerem centralnym przez protokół MQTT.
    \item System musi publikować zdarzenia skanowania kart na topic \texttt{raspberry/rfid/scan}.
    \item Serwer musi odpowiadać z danymi o kliencie lub książce na topic \texttt{raspberry/rfid/response}.
    \item System musi obsługiwać sterowanie diodami LED przez MQTT (topic \texttt{raspberry/led}).
\end{enumerate}

\subsubsection{Informacje zwrotne dla użytkownika terminala}
\begin{enumerate}[label=\textbf{W1.1.6.\arabic*}]
    \item System musi sygnalizować gotowość do skanowania zieloną diodą LED.
    \item System musi sygnalizować przetwarzanie karty czerwoną diodą LED.
    \item System musi emitować dźwięk buzzera po pomyślnym odczytaniu karty.
    \item System musi wyświetlać informacje o stanie operacji na wyświetlaczu OLED (oczekiwanie, wykryto kartę, przetwarzanie, dane klienta/książki).
\end{enumerate}

\subsection{Wymagania niefunkcjonalne}

System musi spełniać następujące wymagania niefunkcjonalne:

\subsubsection{Wydajność}
\begin{enumerate}[label=\textbf{W1.2.1.\arabic*}]
    \item Czas odpowiedzi serwera na żądanie API nie powinien przekraczać 500ms w warunkach normalnego obciążenia.
    \item System musi przetwarzać zdarzenia RFID w czasie rzeczywistym (opóźnienie poniżej 1 sekundy od momentu skanowania do wyświetlenia informacji).
    \item Aplikacja webowa musi ładować się w czasie nie dłuższym niż 3 sekundy przy standardowym połączeniu internetowym.
\end{enumerate}

\subsubsection{Niezawodność i stabilność}
\begin{enumerate}[label=\textbf{W1.2.2.\arabic*}]
    \item System musi być odporny na tymczasową utratę połączenia z brokerem MQTT i automatycznie wznawiać komunikację.
    \item W przypadku błędu odczytu karty RFID, system musi wyświetlić komunikat o błędzie i umożliwić ponowną próbę.
    \item Baza danych musi zapewniać integralność danych (brak duplikatów wypożyczeń, prawidłowe daty operacji).
\end{enumerate}

\subsubsection{Skalowalność}
\begin{enumerate}[label=\textbf{W1.2.3.\arabic*}]
    \item Architektura systemu musi umożliwiać łatwe dodanie kolejnych terminali RFID bez modyfikacji kodu serwera.
    \item Baza danych musi być zaprojektowana w sposób umożliwiający przechowywanie tysięcy rekordów klientów i książek.
\end{enumerate}

\subsubsection{Bezpieczeństwo}
\begin{enumerate}[label=\textbf{W1.2.4.\arabic*}]
    \item Dane w bazie danych muszą być zabezpieczone przed nieautoryzowanym dostępem poprzez odpowiednią konfigurację uprawnień.
    \item System musi walidować wszystkie dane wejściowe z API, aby zapobiec nieprawidłowym operacjom.
\end{enumerate}

\subsubsection{Środowisko uruchomieniowe i przenośność}
\begin{enumerate}[label=\textbf{W1.2.5.\arabic*}]
    \item Terminal RFID musi działać na platformie Raspberry Pi 4B z systemem operacyjnym Raspberry Pi OS.
    \item Serwer backendowy musi być uruchamialny na systemach Linux, macOS i Windows.
    \item Aplikacja webowa musi być kompatybilna z nowoczesnymi przeglądarkami (Chrome, Firefox, Safari, Edge).
    \item System musi umożliwiać uruchomienie brokera MQTT w sieci lokalnej (np. na Raspberry Pi lub innym serwerze).
    \item Baza danych SQLite musi być przenośna i nie wymagać dodatkowej konfiguracji serwera baz danych.
\end{enumerate}

\subsubsection{Technologie i standardy}
\begin{enumerate}[label=\textbf{W1.2.6.\arabic*}]
    \item Backend: Node.js z frameworkiem NestJS, TypeScript, TypeORM.
    \item Frontend: React 19 z TypeScript, React Router, Tailwind CSS, Vite.
    \item Komunikacja IoT: Protokół MQTT z brokerem uruchomionym w sieci lokalnej.
    \item Baza danych: SQLite 3.
    \item Raspberry Pi: Python 3 z bibliotekami paho-mqtt (klient MQTT) i mfrc522 (obsługa czytnika RFID).
    \item Komunikacja w czasie rzeczywistym: WebSockets (Socket.IO) dla aktualizacji interfejsu użytkownika.
\end{enumerate}

\subsubsection{Użyteczność}
\begin{enumerate}[label=\textbf{W1.2.7.\arabic*}]
    \item Interfejs graficzny musi być intuicyjny i nie wymagać specjalistycznego przeszkolenia.
    \item System musi dostarczać jasne komunikaty o stanie operacji (powodzenie, błąd, oczekiwanie).
    \item Wyświetlacz OLED na terminalu RFID musi prezentować czytelne informacje o aktualnym stanie systemu.
    \item Kolorowe diody LED muszą jednoznacznie sygnalizować stan systemu (zielony = gotowy, czerwony = przetwarzanie/błąd).
\end{enumerate}

\subsubsection{Dokumentacja i kod}
\begin{enumerate}[label=\textbf{W1.2.8.\arabic*}]
    \item Kod źródłowy musi być czytelny i zgodny ze standardami danego języka programowania.
    \item Projekt musi zawierać pliki konfiguracyjne umożliwiające łatwe uruchomienie systemu.
\end{enumerate}


\section{Opis implementacji i zastosowanych rozwiązań}

\subsection{Kluczowe elementy implementacji}
W tej sekcji opisano najważniejsze fragmenty kodu odpowiedzialne za kluczowe funkcje systemu.

\subsubsection{Obsługa odczytu kart RFID}
Czytnik RFID na Raspberry Pi wykorzystuje bibliotekę \texttt{mfrc522} do komunikacji z modułem MFRC522. Poniżej przedstawiono kluczowy fragment kodu odpowiedzialny za odczyt karty:

\begin{lstlisting}[language=Python, caption={Odczyt karty RFID - rfid_reader.py}]
class RFIDReader:
    def __init__(self):
        """initialize rfid reader"""
        self.reader = MFRC522()
        print("Czytnik RFID zainicjalizowany")

    def wait_for_card(self):
        """wait for card and return uid"""
        print("\nOczekiwanie na przylozenie karty RFID...")
        
        card_logged = False
        last_seen_time = 0
        card_data = None

        while True:
            now = time.time()
            (status, tag_type) = self.reader.MFRC522_Request(
                self.reader.PICC_REQIDL)

            if status == self.reader.MI_OK:
                (status_uid, uid) = self.reader.MFRC522_Anticoll()

                if status_uid == self.reader.MI_OK:
                    last_seen_time = now
                    if not card_logged:
                        card_logged = True
                        # convert uid to different formats
                        uid_int = 0
                        for i in range(len(uid)):
                            uid_int += uid[i] << (i * 8)
                        uid_hex = "".join([f"{x:02X}" for x in uid])
                        timestamp = datetime.now().strftime(
                            "%Y-%m-%d %H:%M:%S")
                        card_data = {
                            'uid_bytes': list(uid),
                            'uid_hex': uid_hex,
                            'uid_int': uid_int,
                            'timestamp': timestamp
                        }
                        print("\nKarta wykryta!")
                        print(f"   UID (hex): {uid_hex}")
            else:
                if card_logged and (now - last_seen_time) > CARD_RELEASE_DELAY:
                    return card_data
            time.sleep(0.1)
\end{lstlisting}

Funkcja \texttt{wait\_for\_card()} w sposób ciągły sprawdza obecność karty RFID. Po wykryciu karty, odczytuje jej UID i konwertuje go do formatu szesnastkowego oraz całkowitego. System czeka na zabranie karty przed zwróceniem danych, co zapobiega wielokrotnemu odczytowi tej samej karty.

\subsubsection{Obsługa wypożyczeń}
Serwis wypożyczeń w backendzie odpowiada za logikę wypożyczania i zwracania książek:

\begin{lstlisting}[language=TypeScript, caption={Serwis wypożyczeń - borrow.service.ts}]
@Injectable()
export class BorrowService {
  async create(bookCardId: string, clientCardId: string) {
    const book = await this.bookRepo.findOne({ 
      where: { cardId: bookCardId } });
    if (!book) throw new NotFoundException('Book not found');
    
    const client = await this.clientRepo.findOne({ 
      where: { cardId: clientCardId } });
    if (!client) throw new NotFoundException('Client not found');
    
    const borrows = await this.borrowRepo.find({ 
      where: { book: { cardId: bookCardId } }, 
      relations: ['book'] });
    const active = borrows.find(b => b.returnedAt == null);
    if (active) throw new BadRequestException(
      'Book is already borrowed');
    
    const now = new Date();
    const due = new Date();
    due.setDate(now.getDate() + 21);
    const borrow = this.borrowRepo.create({ 
      book, client, borrowedAt: now, dueDate: due });
    return this.borrowRepo.save(borrow);
  }

  async returnBook(borrowId: number) {
    const borrow = await this.findOne(borrowId);
    if (!borrow) throw new NotFoundException('Borrow not found');
    if (borrow.returnedAt) throw new BadRequestException(
      'Book already returned');
    borrow.returnedAt = new Date();
    return this.borrowRepo.save(borrow);
  }
}
\end{lstlisting}

Metoda \texttt{create()} weryfikuje dostępność książki przed utworzeniem wypożyczenia. Domyślny okres wypożyczenia wynosi 21 dni. Metoda \texttt{returnBook()} oznacza wypożyczenie jako zwrócone poprzez ustawienie pola \texttt{returnedAt}.

\subsection{Implementacja komunikacji MQTT}
Komunikacja MQTT jest kluczowym elementem systemu, umożliwiającym wymianę danych między Raspberry Pi a backendem. Poniżej przedstawiono implementację klienta MQTT po stronie Raspberry Pi:

\begin{lstlisting}[language=Python, caption={Klient MQTT - mqtt\_client.py}]
class MQTTClient:
    def __init__(self, on_led_change=None, on_response=None):
        self.client = mqtt.Client(client_id=MQTT_CLIENT_ID)
        self.client.on_connect = self._on_connect
        self.client.on_message = self._on_message
        self.connected = False
        self.on_led_change = on_led_change
        self.on_response = on_response

    def _on_connect(self, client, userdata, flags, rc):
        """callback on broker connection"""
        if rc == 0:
            self.connected = True
            print(f"Polaczono z MQTT brokerem: {MQTT_BROKER}:{MQTT_PORT}")
            # subscribe to backend response topics
            self.client.subscribe(MQTT_TOPIC_LED)
            self.client.subscribe(MQTT_TOPIC_RESPONSE)

    def _on_message(self, client, userdata, msg):
        """callback on mqtt message received"""
        topic = msg.topic
        payload = json.loads(msg.payload.decode())
        
        if topic == MQTT_TOPIC_LED:
            color = payload.get('color', 'unknown')
            if self.on_led_change:
                self.on_led_change(color)
        elif topic == MQTT_TOPIC_RESPONSE:
            if self.on_response:
                self.on_response(payload)

    def publish_scan(self, card_data):
        """publish scanned card info"""
        message = {
            'uid': card_data['uid_hex'],
            'uid_int': card_data['uid_int'],
            'timestamp': card_data['timestamp']
        }
        payload = json.dumps(message)
        result = self.client.publish(MQTT_TOPIC_SCAN, payload)
        return result.rc == mqtt.MQTT_ERR_SUCCESS
\end{lstlisting}

Po stronie backendu, serwis MQTT subskrybuje odpowiednie topiki i przetwarza przychodzące wiadomości:

\begin{lstlisting}[language=TypeScript, caption={Serwis MQTT - mqtt.service.ts}]
@Injectable()
export class MqttService implements OnModuleInit {
  private client: mqtt.MqttClient;
  private messageHandlers: MessageHandler[] = [];

  onModuleInit() {
    const brokerUrl = process.env.MQTT_BROKER_URL || 
      'mqtt://localhost:1883';
    this.client = mqtt.connect(brokerUrl);

    this.client.on('connect', () => {
      this.logger.log(`Connected to MQTT broker ${brokerUrl}`);
      this.client.subscribe('raspberry/rfid/scan');
      this.client.subscribe('raspberry/rfid/cancel');
    });

    this.client.on('message', (topic, payload) => {
      const message = payload.toString();
      this.messageHandlers.forEach(handler => {
        handler(topic, message);
      });
    });
  }

  publish(topic: string, payload: any) {
    const message = typeof payload === 'string' ? 
      payload : JSON.stringify(payload);
    this.client.publish(topic, message);
  }
}
\end{lstlisting}

Struktura topiców MQTT:
\begin{itemize}
    \item \texttt{raspberry/rfid/scan} - Raspberry Pi publikuje tutaj dane zeskanowanej karty.
    \item \texttt{raspberry/rfid/response} - Backend odpowiada z danymi o karcie, kliencie lub książce.
    \item \texttt{raspberry/led} - Backend steruje kolorami diod LED na Raspberry Pi.
    \item \texttt{raspberry/rfid/cancel} - Anulowanie operacji skanowania.
\end{itemize}

\subsection{Szyfrowanie i uwierzytelnianie}
W obecnej wersji systemu komunikacja odbywa się w sieci lokalnej bez szyfrowania. Zastosowano następujące mechanizmy zabezpieczeń:

\begin{itemize}
    \item \textbf{Walidacja danych wejściowych} - Wszystkie dane przychodzące przez API są walidowane za pomocą biblioteki \texttt{class-validator} w NestJS. Przykład walidacji:
    \begin{lstlisting}[language=TypeScript, caption={Przykład walidacji danych}]
export class CreateClientDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsEmail()
  @IsNotEmpty()
  email: string;
}
    \end{lstlisting}
    
    \item \textbf{Integralność danych w bazie} - Baza danych SQLite wykorzystuje relacje i ograniczenia zapewniające integralność danych. Każda karta RFID może być przypisana tylko do jednego klienta lub jednej książki.
    
    \item \textbf{Ochrona przed błędnymi operacjami} - System weryfikuje poprawność operacji przed ich wykonaniem (np. sprawdza, czy książka jest dostępna przed wypożyczeniem, czy klient nie ma już wypożyczonej tej książki).
    
    \item \textbf{Komunikacja w sieci lokalnej} - W wersji produkcyjnej zaleca się implementację:
    \begin{itemize}
        \item Szyfrowania TLS/SSL dla komunikacji MQTT (MQTTS).
        \item Uwierzytelniania użytkowników w aplikacji webowej (np. JWT).
    \end{itemize}
\end{itemize}

\subsection{Inne istotne rozwiązania}

\subsubsection{Komunikacja w czasie rzeczywistym przez WebSockets}
System wykorzystuje Socket.IO do przekazywania aktualizacji z backendu do frontendu w czasie rzeczywistym. Gdy Raspberry Pi skanuje kartę, backend natychmiast emituje zdarzenie do wszystkich podłączonych klientów webowych:

\begin{lstlisting}[language=TypeScript, caption={Gateway WebSocket - events.gateway.ts}]
@WebSocketGateway({ cors: { origin: '*' } })
export class EventsGateway {
  @WebSocketServer()
  server: Server;

  emit(event: string, data: any) {
    this.server.emit(event, data);
  }
}
\end{lstlisting}

W serwisie RFID, po przetworzeniu skanowania karty, emitowane jest zdarzenie:
\begin{lstlisting}[language=TypeScript]
this.gateway.emit('rfid/scanned', response);
\end{lstlisting}

\subsubsection{Automatyczne tworzenie kart}
System automatycznie tworzy nowe rekordy kart w bazie danych przy pierwszym skanowaniu nieznanego UID. Pozwala to na elastyczne zarządzanie kartami bez konieczności ręcznego dodawania każdej karty przed użyciem.

\subsubsection{Obsługa błędów i timeoutów}
System implementuje mechanizmy obsługi błędów:
\begin{itemize}
    \item Timeout dla operacji skanowania (domyślnie 10 sekund).
    \item Automatyczne przełączanie LED na zielony po zakończeniu operacji.
    \item Generyczny komunikat o błędzie wyświetlany na wyświetlaczu OLED.
    \item Logowanie wszystkich operacji w konsoli dla celów diagnostycznych.
\end{itemize}

\section{Opis architektury systemu}

System został zaprojektowany w architekturze wielowarstwowej. Składa się z następujących elementów:
\begin{itemize}
    \item warstwy klienckiej (aplikacja webowa React),
    \item warstwy serwerowej (backend NestJS),
    \item warstwy komunikacyjnej (MQTT, WebSockets),
    \item warstwy danych (baza danych SQLite),
    \item warstwy urządzeń IoT (Raspberry Pi z czytnikiem RFID).
\end{itemize}

\subsection{Schemat architektury aplikacji}
Poniżej przedstawiono schemat architektury systemu z uwzględnieniem architektury sieciowej.

Architektura systemu opiera się na następujących komponentach:
\begin{itemize}
    \item \textbf{Frontend (React)} - aplikacja webowa działająca w przeglądarce, komunikująca się z backendem przez REST API i WebSockets (Socket.IO).
    \item \textbf{Backend (NestJS)} - serwer aplikacyjny obsługujący logikę biznesową, komunikujący się z bazą danych SQLite oraz brokerem MQTT.
    \item \textbf{Broker MQTT} - broker komunikacji MQTT uruchomiony w sieci lokalnej (np. na Raspberry Pi lub osobnym serwerze), pośredniczący w komunikacji między terminalem RFID a backendem.
    \item \textbf{Raspberry Pi} - terminal RFID wyposażony w czytnik MFRC522, diody LED, buzzer i wyświetlacz OLED, komunikujący się z backendem przez protokół MQTT.
    \item \textbf{Baza danych SQLite} - lokalna baza danych przechowująca informacje o klientach, książkach, kartach RFID i wypożyczeniach.
\end{itemize}

Komunikacja w systemie odbywa się następująco:
\begin{itemize}
    \item Raspberry Pi publikuje zdarzenia skanowania kart na topic \texttt{raspberry/rfid/scan}.
    \item Backend subskrybuje ten topic, przetwarza dane i odpowiada na topic\newline \texttt{raspberry/rfid/response}.
    \item Backend steruje diodami LED na Raspberry Pi przez topic \texttt{raspberry/led}.
    \item Frontend otrzymuje aktualizacje w czasie rzeczywistym przez WebSockets (Socket.IO).
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{ArchitekturaIOT.png}
    \caption{Schemat architektury systemu}
    \label{fig:architectue}
\end{figure}

\section{Opis działania i prezentacja interfejsu}

\subsection{Instalacja i uruchomienie aplikacji}

\subsubsection{Wymagania systemowe}
\begin{itemize}
    \item Node.js w wersji 18 lub nowszej
    \item Python 3.8 lub nowszy
    \item Docker i Docker Compose (dla brokera MQTT, jeśli nie będzie on postawiony na Raspberry Pi)
    \item npm lub yarn
    \item Raspberry Pi 4B z systemem Raspberry Pi OS (dla terminala RFID)
\end{itemize}

\subsubsection{Instalacja i uruchomienie brokera MQTT}
Broker MQTT (Eclipse Mosquitto) jest uruchamiany w kontenerze Docker:

\begin{enumerate}
    \item Przejdź do katalogu \texttt{mqtt/}:
    \begin{verbatim}
cd mqtt
    \end{verbatim}
    \item Uruchom kontener Docker:
    \begin{verbatim}
docker-compose up -d
    \end{verbatim}
    \item Broker będzie dostępny na porcie 1883 (domyślnie \texttt{localhost:1883}).
\end{enumerate}

\subsubsection{Instalacja i uruchomienie backendu}
\begin{enumerate}
    \item Przejdź do katalogu \texttt{backend\_nestjs/}:
    \begin{verbatim}
cd backend_nestjs
    \end{verbatim}
    \item Zainstaluj zależności:
    \begin{verbatim}
npm install
    \end{verbatim}
    \item (Opcjonalnie) Skonfiguruj zmienne środowiskowe w pliku \texttt{.env}:
    \begin{verbatim}
PORT=3000
MQTT_BROKER_URL=mqtt://localhost:1883
MQTT_ENABLED=true
DB_DATABASE=database.sqlite
    \end{verbatim}
    \item Uruchom serwer w trybie deweloperskim:
    \begin{verbatim}
npm run start:dev
    \end{verbatim}
    \item Serwer będzie dostępny pod adresem \texttt{http://localhost:3000}.
    \item Baza danych SQLite zostanie automatycznie utworzona przy pierwszym uruchomieniu wraz z przykładowymi danymi.
\end{enumerate}

\subsubsection{Instalacja i uruchomienie frontendu}
\begin{enumerate}
    \item Przejdź do katalogu \texttt{frontend\_react/}:
    \begin{verbatim}
cd frontend_react
    \end{verbatim}
    \item Zainstaluj zależności:
    \begin{verbatim}
npm install
    \end{verbatim}
    \item Uruchom aplikację w trybie deweloperskim:
    \begin{verbatim}
npm run dev
    \end{verbatim}
    \item Aplikacja będzie dostępna pod adresem \texttt{http://localhost:5173}.
\end{enumerate}

\subsubsection{Instalacja i uruchomienie terminala RFID na Raspberry Pi}
\begin{enumerate}
    \item Skopiuj katalog \texttt{raspberry-pi-python/} na Raspberry Pi.
    \item Zainstaluj wymagane biblioteki Python:
    \begin{verbatim}
pip3 install -r requirements.txt
    \end{verbatim}
    \item Skonfiguruj adres brokera MQTT w pliku \texttt{config.py}:
    \begin{verbatim}
MQTT_BROKER = "IP_ADRES_BACKENDU"
MQTT_PORT = 1883
    \end{verbatim}
    \item Uruchom główny skrypt:
    \begin{verbatim}
python3 main.py
    \end{verbatim}
\end{enumerate}

\subsubsection{Weryfikacja działania systemu}
Po uruchomieniu wszystkich komponentów:
\begin{enumerate}
    \item Otwórz aplikację webową w przeglądarce (\texttt{http://localhost:5173}).
    \item Sprawdź, czy backend odpowiada (API dostępne pod \texttt{http://localhost:3000}).
    \item Sprawdź, czy broker MQTT działa (można użyć narzędzi takich jak MQTT Explorer).
    \item Przetestuj skanowanie karty RFID na Raspberry Pi - informacje powinny pojawić się w aplikacji webowej w czasie rzeczywistym.
\end{enumerate}

Aplikacja webowa oferuje następujące funkcjonalności:

\subsubsection{Strona główna}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{Zrzut ekranu z 2026-01-12 12-17-02.png}
    \caption{Strona główna}
    \label{fig:home}
\end{figure}

Strona główna pełni funkcję centrum nawigacyjnego systemu. Zawiera sekcję hero z tytułem i opisem systemu, dwie główne karty akcji umożliwiające skanowanie kart RFID użytkowników i książek, sekcję szybkiego dostępu z przyciskami prowadzącymi do listy użytkowników i książek, oraz sekcję informacyjną "Jak to działa?" wyjaśniającą proces korzystania z systemu w trzech krokach. Po kliknięciu karty skanowania, wyświetla się dialog z instrukcjami, a system oczekuje na przyłożenie karty RFID do czytnika.

\subsubsection{Zarządzanie klientami}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{lista_klientow.png}
    \caption{Lista klientów}
    \label{fig:clients}
\end{figure}

Strona \texttt{/clients} umożliwia:
\begin{itemize}
    \item Przeglądanie listy wszystkich klientów biblioteki.
    \item Dodawanie nowych klientów (imię, nazwisko, email).
    \item Edycję danych istniejących klientów.
    \item Usuwanie klientów.
    \item Przypisywanie kart RFID do klientów.
    \item Przeglądanie historii wypożyczeń danego klienta.
\end{itemize}

\subsubsection{Zarządzanie książkami}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{lista_ksiazek.png}
    \caption{Lista książek}
    \label{fig:books}
\end{figure}
Strona \texttt{/books} umożliwia:
\begin{itemize}
    \item Przeglądanie listy wszystkich książek w bibliotece.
    \item Dodawanie nowych książek (tytuł, autor).
    \item Edycję danych istniejących książek.
    \item Usuwanie książek.
    \item Przypisywanie kart RFID do książek.
    \item Sprawdzanie dostępności książek.
\end{itemize}

\subsubsection{Proces wypożyczania i zwracania}
System umożliwia wypożyczanie i zwracanie książek na dwa sposoby:
\begin{enumerate}
    \item \textbf{Przez terminal RFID:}
    \begin{figure}
        \centering
        \includegraphics[width=1\linewidth]{Zrzut ekranu z 2026-01-12 12-26-11.png}
        \caption{Wypożyczenie}
        \label{fig:rent}
    \end{figure}
    \begin{itemize}
        \item Zeskanuj kartę klienta (LED zmieni się na zielony).
        \item Zeskanuj kartę książki (system automatycznie utworzy wypożyczenie).
        \item Informacja o wypożyczeniu pojawi się w aplikacji webowej w czasie rzeczywistym.
    \end{itemize}
    \item \textbf{Przez interfejs webowy:}
    \begin{itemize}
        \item Wybierz klienta i książkę z listy.
        \item Kliknij przycisk "Wypożycz" lub "Zwróć".
        \item System automatycznie zaktualizuje status wypożyczenia.
    \end{itemize}
\end{enumerate}

\subsubsection{Wyświetlacz OLED na terminalu RFID}
Terminal RFID wyświetla następujące informacje na wyświetlaczu OLED:
\begin{itemize}
    \item \textbf{Oczekiwanie na kartę} - komunikat zachęcający do przyłożenia karty.
    \item \textbf{Wykryto kartę} - wyświetlenie UID zeskanowanej karty.
    \item \textbf{Przetwarzanie} - informacja o przetwarzaniu danych przez backend.
    \item \textbf{Dane klienta/książki} - wyświetlenie informacji o znalezionym kliencie lub książce.
    \item \textbf{Nowa karta} - informacja o nieznanej karcie.
    \item \textbf{Błąd} - komunikat o błędzie operacji.
\end{itemize}


\section{Opis wkładu pracy Autorów}

\subsection{Dawid Błaszczyk}
\begin{itemize}
    \item Konfiguracja i uruchomienie środowiska do testowania komunikacji MQTT.
    \item Testowanie integracji między komponentami systemu.
    \item Dokumentacja projektu i przygotowanie raportu.
    \item Weryfikacja zgodności z wymaganiami funkcjonalnymi i niefunkcjonalnymi.
    \item Przygotowanie instrukcji instalacji i uruchomienia.
    \item Testowanie scenariuszy użycia i identyfikacja błędów.
    \item Projekt i implementacja interfejsu użytkownika z wykorzystaniem Tailwind CSS.
\end{itemize}

\subsection{Błazej Kowal}
\begin{itemize}
    \item Implementacja backendu w NestJS (struktura modułów, serwisy, kontrolery).
    \item Implementacja komunikacji MQTT między Raspberry Pi a backendem.
    \item Implementacja WebSockets (Socket.IO) dla aktualizacji w czasie rzeczywistym.
    \item Projekt i implementacja bazy danych SQLite z wykorzystaniem TypeORM.
    \item Implementacja logiki wypożyczeń i zwrotów książek.
    \item Integracja wszystkich komponentów systemu.
    

    \item Szacunkowy wkład procentowy: 25\%.
\end{itemize}

\subsection{Alina Lenart}
\begin{itemize}
    \item Implementacja kodu Python dla Raspberry Pi (czytnik RFID, MQTT client).
    \item Implementacja obsługi wyświetlacza OLED.
    \item Implementacja kontroli diod LED i buzzera.
    \item Testowanie i debugowanie komunikacji MQTT.
    \item Dokumentacja kodu Python i instrukcje instalacji.
    \item Implementacja symulatora Raspberry Pi do testowania bez fizycznego urządzenia.
\end{itemize}

\subsection{Bartosz Wacławiak}
\begin{itemize}
    \item Implementacja aplikacji webowej w React z TypeScript.
    \item Implementacja routingu i nawigacji w aplikacji (React Router).
    \item Implementacja komunikacji z backendem przez REST API.
    \item Implementacja integracji z WebSockets dla aktualizacji w czasie rzeczywistym.
    \item Implementacja komponentów do zarządzania klientami, książkami i wypożyczeniami.

\end{itemize}

\section{Podsumowanie}

Projekt został zrealizowany zgodnie z założonymi wymaganiami funkcjonalnymi i niefunkcjonalnymi. System biblioteczny IoT spełnia wszystkie podstawowe wymagania:

\subsection{Stopień zgodności z wymaganiami}

\subsubsection{Wymagania funkcjonalne}
Wszystkie wymagania funkcjonalne zostały zrealizowane:
\begin{itemize}
    \item ✓ System umożliwia odczyt kart RFID za pomocą czytnika MFRC522.
    \item ✓ System automatycznie wykrywa przyłożenie i zabranie karty RFID.
    \item ✓ Odczytany identyfikator karty jest konwertowany do formatu szesnastkowego i przesyłany do serwera.
    \item ✓ System rozróżnia między kartami klientów i książek.
    \item ✓ System przechowuje informacje o klientach, książkach i wypożyczeniach w bazie danych SQLite.
    \item ✓ System umożliwia wypożyczanie i zwracanie książek przez skanowanie kart.
    \item ✓ System posiada webowy interfejs graficzny z pełną funkcjonalnością zarządzania.
    \item ✓ Komunikacja MQTT działa poprawnie między Raspberry Pi a backendem.
    \item ✓ System sygnalizuje stany operacji za pomocą diod LED, buzzera i wyświetlacza OLED.
\end{itemize}

\subsubsection{Wymagania niefunkcjonalne}
Większość wymagań niefunkcjonalnych została spełniona:
\begin{itemize}
    \item ✓ System przetwarza zdarzenia RFID w czasie rzeczywistym (opóźnienie < 1s).
    \item ✓ Aplikacja webowa ładuje się szybko dzięki wykorzystaniu Vite i React.
    \item ✓ System jest odporny na tymczasową utratę połączenia z brokerem MQTT.
    \item ✓ Baza danych zapewnia integralność danych.
    \item ✓ Architektura umożliwia łatwe dodanie kolejnych terminali RFID.
    \item ✓ System działa na wymaganych platformach (Linux, macOS, Windows dla backendu, Raspberry Pi OS dla terminala).
    \item ⚠ Komunikacja MQTT odbywa się bez szyfrowania (zgodnie z założeniami dla wersji proof-of-concept w sieci lokalnej).
\end{itemize}

\subsection{Napotkane trudności}

W trakcie implementacji napotkano na następujące trudności:

\subsubsection{Problemy techniczne}
\begin{itemize}
    \item \textbf{Integracja WebSockets z React} - Wymagało to właściwej konfiguracji Socket.IO po stronie klienta i serwera oraz obsługi reconnectów.
    \item \textbf{Konfiguracja CORS} - Wymagana była odpowiednia konfiguracja CORS w backendzie NestJS oraz WebSocket Gateway dla komunikacji między frontendem a backendem.
\end{itemize}

\subsubsection{Ograniczenia}
\begin{itemize}
    \item \textbf{Brak fizycznego urządzenia podczas części rozwoju} - Część funkcjonalności była testowana przy użyciu symulatora Raspberry Pi, co wymagało dodatkowego czasu na weryfikację na rzeczywistym urządzeniu.
\end{itemize}

\subsection{Kierunki dalszego rozwoju systemu}

Możliwe kierunki rozbudowy i ulepszeń systemu:

\subsubsection{Rozbudowa funkcjonalności}
\begin{itemize}
    \item System kar za przetrzymanie książek.
    \item Historia wypożyczeń z możliwością eksportu do pliku.
    \item Wyszukiwarka zaawansowana z filtrowaniem po wielu kryteriach.
    \item System powiadomień email/SMS o terminach zwrotu.
    \item Obsługa wielu bibliotek w jednym systemie.
\end{itemize}

\subsubsection{Poprawa bezpieczeństwa}
\begin{itemize}
    \item Szyfrowanie komunikacji MQTT (MQTTS z certyfikatami TLS/SSL).
\end{itemize}

\subsubsection{Optymalizacja wydajności}
\begin{itemize}
    \item Migracja z SQLite do PostgreSQL lub MySQL dla większej wydajności i skalowalności.
    \item Implementacja paginacji dla dużych list danych.
    \item Lazy loading komponentów w aplikacji React.
\end{itemize}

\subsubsection{Ulepszenia techniczne}
\begin{itemize}
    \item Implementacja testów jednostkowych i integracyjnych.
    \item CI/CD pipeline dla automatycznego testowania i wdrażania.
    \item Dokumentacja API (Swagger/OpenAPI).
    \item Wsparcie dla wielu języków (i18n).
\end{itemize}

\section{Literatura}

\begin{itemize}
    \item NestJS Documentation. \textit{Official NestJS Documentation}. Dostępne online: \url{https://docs.nestjs.com/}.
    \item React Documentation. \textit{React - A JavaScript library for building user interfaces}. Dostępne online: \url{https://react.dev/}.
    \item TypeORM Documentation. \textit{TypeORM - Amazing ORM for TypeScript and JavaScript}. Dostępne online: \url{https://typeorm.io/}.
    \item MQTT.org. \textit{MQTT - The Standard for IoT Messaging}. Dostępne online: \url{https://mqtt.org/}.
    \item Paho MQTT Python Client. \textit{Eclipse Paho MQTT Python Client Library}. Dostępne online: \url{https://www.eclipse.org/paho/index.php?page=clients/python/docs/index.php}.
    \item MFRC522 Python Library. \textit{MFRC522-python - A Python library for the MFRC522 RFID reader}. Dostępne online: \url{https://github.com/mxgxw/MFRC522-python}.
    \item Socket.IO Documentation. \textit{Socket.IO - Bidirectional and low-latency communication for every platform}. Dostępne online: \url{https://socket.io/docs/v4/}.
    \item Tailwind CSS Documentation. \textit{Tailwind CSS - Rapidly build modern websites}. Dostępne online: \url{https://tailwindcss.com/docs}.
    \item Vite Documentation. \textit{Vite - Next Generation Frontend Tooling}. Dostępne online: \url{https://vitejs.dev/}.
    \item SQLite Documentation. \textit{SQLite - A self-contained, serverless, zero-configuration SQL database engine}. Dostępne online: \url{https://www.sqlite.org/docs.html}.
    \item Raspberry Pi Foundation. \textit{Raspberry Pi Documentation}. Dostępne online: \url{https://www.raspberrypi.com/documentation/}.
    \item TypeScript Documentation. \textit{TypeScript - JavaScript with syntax for types}. Dostępne online: \url{https://www.typescriptlang.org/docs/}.
\end{itemize}

\section{Aneks}

Kod źródłowy projektu został dołączony w formie elektronicznej jako załącznik. Projekt zawiera następujące komponenty:

\begin{itemize}
    \item \texttt{backend\_nestjs/} - Kod źródłowy backendu w NestJS (TypeScript).
    \item \texttt{frontend\_react/} - Kod źródłowy aplikacji webowej w React (TypeScript).
    \item \texttt{raspberry-pi-python/} - Kod źródłowy aplikacji dla Raspberry Pi (Python).
    \item \texttt{mqtt/} - Skrypty i konfiguracja pomocnicza do testów komunikacji MQTT.
    \item \texttt{rpi-simulators/} - Symulator Raspberry Pi do testowania bez fizycznego urządzenia.
    \item \texttt{raport/} - Dokumentacja projektu (LaTeX).
\end{itemize}

Wszystkie pliki konfiguracyjne, zależności i instrukcje instalacji znajdują się w odpowiednich katalogach projektu.

\end{document}